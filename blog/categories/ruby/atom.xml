<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | jtobin.ca]]></title>
  <link href="http://jtobin.ca/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://jtobin.ca/"/>
  <updated>2014-12-03T14:17:07+13:00</updated>
  <id>http://jtobin.ca/</id>
  <author>
    <name><![CDATA[Jared Tobin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Property Testing in Ruby]]></title>
    <link href="http://jtobin.ca/blog/2014/03/09/property-testing-in-ruby/"/>
    <updated>2014-03-09T11:09:56+13:00</updated>
    <id>http://jtobin.ca/blog/2014/03/09/property-testing-in-ruby</id>
    <content type="html"><![CDATA[<p>Testing properties of Haskell functions with
<a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> is easy and pretty
enjoyable.  It turns out Ruby has a QuickCheck-like property testing library
called <a href="http://github.com/hayeah/rantly">rantly</a>.</p>

<p>Let’s test the ‘greed game’ <a href="http://rubykoans.com/">Ruby koan</a>.  In the greed
game, one rolls up to five dice and calculates a score according to the
following rules:</p>

<ul>
  <li>three ones is 1000 points</li>
  <li>three of the same non-one number is worth 100 times that number</li>
  <li>a one that is not a part of a set of three is worth 100 points</li>
  <li>a five that is not a part of a set of three is worth 50 points</li>
  <li>everything else is worth one point</li>
</ul>

<p>So, for example, a roll of 1, 1, 1, 5, 1 would yield 1150 points.  A roll of
3, 4, 5, 3, 3 would yield 350 points.</p>

<p>The basic scoring mechanism can be implemented like so:</p>

<p>``` ruby 
require ‘rantly/property’</p>

<p>def score(ds)
  (ds.group_by { |i| i }.map { |k, v| score_group k, v.count }.reduce :+) || 0
end</p>

<p>def score_group(k, v)
  value_score  = { 1 =&gt; 100, 5 =&gt; 50}[k] || 0
  triple_score = k == 1 ? 1000 : k * 100</p>

<p>v &gt;= 3 ? triple_score + value_score * (v - 3) : value_score * v
end
```</p>

<p>Property tests require generators to cook up requisite input data.  Some
generators we might be interested in, to start, are those to create valid dice
rolls:</p>

<p><code>ruby
valid_roll   = -&gt; { Rantly { range 1, 6 } }
valid_number = -&gt; { Rantly { range 0, 5 } }
</code></p>

<p><code>valid_roll</code> describes the result of an individual dice roll, while
<code>valid_number</code> describes the number of dice that can be rolled for an input
score.  <code>range</code> generates a value between its provided arguments, inclusive.
Rantly comes equipped with a bunch of primitive generators and combinators:
<code>choose</code>, <code>array</code>, <code>sized</code>, etc.</p>

<p>We can use those primitive generators to create other generators.  In
particular, a valid input to the <code>score</code> function should be a 0-to-5 length
array in which each element is between 1 and 6 inclusive; that is, an array
with length generated from <code>valid_number</code> and elements generated from
<code>valid_roll</code>.</p>

<p>Below, I’ll create that composite generator in an RSpec <code>describe</code> block and
then test a couple of properties of the <code>score</code> function:</p>

<p>``` ruby
describe ‘score’ do</p>

<p>let (:rolls) do
    -&gt;(r) { sized(valid_number.call) { array { valid_roll.call } } }
  end</p>

<p>it ‘should be non-negative’ do
    property_of(&amp;rolls).check(750) do |r|
      expect(score r).to be &gt;= 0
    end
  end</p>

<p>it ‘should be less than or equal to 1200’ do
    property_of(&amp;rolls).check(750) do |r|
      expect(score r).to be &lt;= 1200
    end
  end</p>

<p>end
```</p>

<p>Running this code will test each of those properties on 750 random inputs
generated by the <code>rolls</code> generator.</p>

<p>One might also want to test how functions behave on invalid input.  Let’s
augment the original scoring functions with some exception handling:</p>

<p>``` ruby
def score(ds)
  fail ArgumentError, ‘invalid argument’ unless ds.count.between?(0, 5)</p>

<p>begin
    groups = ds.group_by { |i| i }
    (groups.map { |k, v| score_group k, v.count }.reduce :+) || 0
  rescue ArgumentError
    raise ArgumentError, ‘invalid argument’
  end
end</p>

<p>def score_group(k, v)
  fail ArgumentError unless k.between?(1, 6)
  fail ArgumentError unless v.between?(1, 5)</p>

<p>value_score  = { 1 =&gt; 100, 5 =&gt; 50 }[k] || 0
  triple_score = k == 1 ? 1000 : k * 100</p>

<p>v &gt;= 3 ? triple_score + value_score * (v - 3) : value_score * v
end</p>

<p>```</p>

<p>and then add generators for invalid rolls:</p>

<p><code>ruby
invalid_roll   = -&gt; { Rantly { choose 0, 7 } }
invalid_number = -&gt; { Rantly { choose 6, 10, 50 } }
</code></p>

<p>then, with the addition of two new composite generators,  we can test that the
exception handling behaves as we expect:</p>

<p>``` ruby
describe ‘score’ do</p>

<p>let(:rolls) do
    -&gt;(r) { sized(valid_number.call) { array { valid_roll.call } } }
  end</p>

<p>let(:rolls_invalid_number) do
    -&gt;(r) { sized(invalid_number.call) { array { valid_roll.call } } }
  end</p>

<p>let(:rolls_invalid_roll) do
    -&gt;(r) { sized(valid_number.call) { array { invalid_roll.call } } }
  end</p>

<p>it ‘should be non-negative’ do
    property_of(&amp;rolls).check(750) do |r|
      expect(score r).to be &gt;= 0
    end
  end</p>

<p>it ‘should be less than or equal to 1200’ do
    property_of(&amp;rolls).check(750) do |r|
      expect(score r).to be &lt;= 1200
    end
  end</p>

<p>it ‘should raise an error for an invalid number of rolls’ do
    property_of(&amp;rolls_invalid_number).check(750) do |r|
      expect { score r }.to raise_error(ArgumentError)
    end
  end</p>

<p>it ‘should raise an error for an invalid roll value’ do
    property_of(&amp;rolls_invalid_roll).check(750) do |r|
      expect { score r }.to raise_error(ArgumentError) if r.count &gt; 0
    end
  end</p>

<p>end
```</p>

<p>As often happens, property testing tends to suss out weird corner cases in your
code and help you understand it better.  Just while doing this example I
realized that <code>ArgumentError</code> wouldn’t necessarily be thrown for an invalid
roll <em>value</em> if the number of input rolls was actually empty.  Hence, the
addition of <code>if r.count &gt; 0</code> to the last test.</p>

<p>Property testing also subsumes unit tests.  If you use a static or relatively
static generator, you’re effectively <em>doing</em> unit testing.  You can see this in
the cases of the <code>invalid_roll</code> and <code>invalid_number</code> generators, in which each
is generating inputs from only a very small domain.</p>

<p>IMO familiarity with a QuickCheck-like property testing library is good to
have.  Rantly is not quite QuickCheck, but it’s still a joy to use.</p>

]]></content>
  </entry>
  
</feed>
