
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Sharing in Haskell EDSLs - jtobin.ca</title>
  <meta name="author" content="Jared Tobin">

  
  <meta name="description" content="Lately I’ve been trying to do some magic by way of nonstandard interpretations
of abstract syntax. One of the things that I’ve managed to grok along &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jtobin.ca/blog/2014/05/30/sharing-in-haskell-edsls/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="jtobin.ca" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-22260080-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body    class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">jtobin.ca</a>  &#47; <a href="/blog/archives">archives</a> &#47; <a href="/about">about</a> </h1>
  
  <div class="clear"></div>
</hgroup>

</header>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Sharing in Haskell EDSLs</h1>
      
    
    
      <p class="meta">
        
      </p>
    
  </header>


<div class="entry-content"><p>Lately I’ve been trying to do some magic by way of nonstandard interpretations
of abstract syntax.  One of the things that I’ve managed to grok along the way
has been the problem of <em>sharing</em> in deeply-embedded languages.</p>

<p>Here’s a simple illustration of the ‘vanilla’ sharing problem by way of plain
Haskell; a function that computes 2^n:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">naiveTree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">naiveTree</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">naiveTree</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">naiveTree</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">naiveTree</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This naive implementation is a poor way to roll as it is exponentially complex
in n.  Look at how evaluation proceeds for something like <code>naiveTree 4</code>:</p>

<pre><code>&gt; naiveTree 4
&gt; naiveTree 3 + naiveTree 3
&gt; naiveTree 2 + naiveTree 2 + naiveTree 2 + naiveTree 2
&gt; naiveTree 1 + naiveTree 1 + naiveTree 1 + naiveTree 1
  + naiveTree 1 + naiveTree 1 + naiveTree 1 + naiveTree 1
&gt; naiveTree 0 + naiveTree 0 + naiveTree 0 + naiveTree 0
  + naiveTree 0 + naiveTree 0 + naiveTree 0 + naiveTree 0
  + naiveTree 0 + naiveTree 0 + naiveTree 0 + naiveTree 0
  + naiveTree 0 + naiveTree 0 + naiveTree 0 + naiveTree 0
&gt; 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
&gt; 16
</code></pre>

<p>Each recursive call doubles the number of function evaluations we need to make.
Don’t wait up for <code>naiveTree 50</code> to return a value.</p>

<p>A better way to write this function would be:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">tree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class="line"><span class="nf">tree</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">tree</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class="line">  <span class="kr">let</span> <span class="n">shared</span> <span class="ow">=</span> <span class="n">tree</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">  <span class="kr">in</span>  <span class="n">shared</span> <span class="o">+</span> <span class="n">shared</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we store solutions to subproblems, and thus avoid having to recompute
things over and over.  Look at how <code>tree 4</code> proceeds now:</p>

<pre><code>&gt; tree 4
&gt; let shared0 =
      let shared1 = 
          let shared2 =
              let shared3 = 1 
              in  shared3 + shared3
          in  shared2 + shared2
      in  shared1 + shared1
  in  shared0 + shared0
&gt; let shared0 =
      let shared1 = 
          let shared2 = 2
          in  shared2 + shared2
      in  shared1 + shared1
  in  shared0 + shared0
&gt; let shared0 =
      let shared1 = 4
      in  shared1 + shared1
  in  shared0 + shared0
&gt; let shared0 = 8
  in  shared0 + shared0
&gt; 16
</code></pre>

<p>You could say that Haskell’s <code>let</code> syntax enables <em>sharing</em> between
computations; using it reduces the complexity of our tree implementation from
$O(2^n)$ to $O(n)$.  <code>tree 50</code> now returns instantly:</p>

<pre><code>&gt; tree 50
1125899906842624
</code></pre>

<p>So let’s move everything over to an abstract syntax setting and see how the
results translate there.</p>

<p>Let’s start with a minimalist language, known in some circles as Hutton’s
Razor.  While puny, it is sufficiently expressive to illustrate the subtleties
of this whole sharing business:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Expr</span> <span class="ow">=</span>
</span><span class="line">    <span class="kt">Lit</span> <span class="kt">Int</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Add</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
</span><span class="line">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">Num</span> <span class="kt">Expr</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">fromInteger</span> <span class="ow">=</span> <span class="kt">Lit</span> <span class="o">.</span> <span class="n">fromInteger</span>
</span><span class="line">  <span class="p">(</span><span class="o">+</span><span class="p">)</span>         <span class="ow">=</span> <span class="kt">Add</span>
</span><span class="line">
</span><span class="line"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">d</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">d</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">e1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>I’ve provided a <code>Num</code> instance so that we can conveniently write expressions in
this language.  We can use conventional notation and extract abstract syntax
for free by specifying a particular type signature:</p>

<pre><code>&gt; 1 + 1 :: Expr
Add (Lit 1) (Lit 1)
</code></pre>

<p>And of course we can use <code>eval</code> to evaluate things:</p>

<pre><code>&gt; eval (1 + 1 :: Expr)
2
</code></pre>

<p>Due to the <code>Num</code> instance and the polymorphic definitions of <code>naiveTree</code> and
<code>tree</code>, these functions will automatically work on our expression type.  Check
them out:</p>

<pre><code>&gt; naiveTree 2 :: Expr
Add (Add (Lit 1) (Lit 1)) (Add (Lit 1) (Lit 1))

&gt; tree 2 :: Expr
Add (Add (Lit 1) (Lit 1)) (Add (Lit 1) (Lit 1))
</code></pre>

<p>Notice there’s a quirk here: each of these functions - having wildly different
complexities - yields the same abstract syntax, implying that <code>tree</code> is no
more efficient than <code>naiveTree</code> when it comes to dealing with this expression
type.  That means..</p>

<pre><code>&gt; eval (tree 50 :: Expr)
-- ain't happening
</code></pre>

<p>So there is a big problem here: Haskell’s <code>let</code> syntax doesn’t carry its
sharing over to our embedded language.  Equivalently, the embedded language is
<em>not expressive enough</em> to represent sharing in its own abstract syntax.</p>

<p>There are a few ways to get around this.</p>

<h2 id="memoizing-evaluation">Memoizing Evaluation</h2>

<p>For some interpretations (like evaluation) we can use a memoization library.
Here we can use <code>Data.StableMemo</code> to define a clean and simple evaluator:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">import</span> <span class="nn">Data.StableMemo</span>
</span><span class="line">
</span><span class="line"><span class="nf">memoEval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">memoEval</span> <span class="ow">=</span> <span class="n">go</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">go</span> <span class="ow">=</span> <span class="n">memo</span> <span class="n">eval</span>
</span><span class="line">  <span class="n">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">i</span>
</span><span class="line">  <span class="n">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">go</span> <span class="n">e1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This will very conveniently handle any grimy details of caching intermediate
computations.  It passes the <code>tree 50</code> test just fine:</p>

<pre><code>&gt; memoEval (tree 50 :: Expr)
1125899906842624
</code></pre>

<p>Some other interpretations are still inefficient; a similar <code>memoPrint</code>
function will still dump out a massive syntax tree due to the limited
expressiveness of the embedded language.  The memoizer doesn’t really allow us
to <em>observe</em> sharing, if we’re interested in doing that for some reason.</p>

<h2 id="observing-implicit-sharing">Observing Implicit Sharing</h2>

<p>We can actually use GHC’s internal sharing analysis to recover any implicit
sharing present in an embedded expression.  This is the technique introduced by
Andy Gill’s <a href="http://www.cs.uu.nl/wiki/pub/Afp/CourseLiterature/Gill-09-TypeSafeReification.pdf">Type Safe Observable Sharing In
Haskell</a>
and implemented in the <code>data-reify</code> library on
<a href="http://hackage.haskell.org/package/data-reify">Hackage</a>.  It’s as
technically unsafe as it sounds, but in practice has the benefits of being both
relatively benign and minimally intrusive on the existing language.</p>

<p>Here is the extra machinery required to observe implicit sharing in our <code>Expr</code>
type:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="cm">{-# LANGUAGE DeriveFunctor #-}</span>
</span><span class="line"><span class="cm">{-# LANGUAGE TypeFamilies #-}</span>
</span><span class="line">
</span><span class="line"><span class="kr">import</span> <span class="nn">Control.Applicative</span>
</span><span class="line"><span class="kr">import</span> <span class="nn">Data.Reify</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">Graph</span><span class="p">)</span>
</span><span class="line"><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Reify</span> <span class="k">as</span> <span class="n">Reify</span>
</span><span class="line"><span class="kr">import</span> <span class="nn">System.IO.Unsafe</span>
</span><span class="line">
</span><span class="line"><span class="kr">data</span> <span class="kt">ExprF</span> <span class="n">e</span> <span class="ow">=</span>
</span><span class="line">    <span class="kt">LitF</span> <span class="kt">Int</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">AddF</span> <span class="n">e</span> <span class="n">e</span>
</span><span class="line">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Functor</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="kr">instance</span> <span class="kt">MuRef</span> <span class="kt">Expr</span> <span class="kr">where</span>
</span><span class="line">  <span class="kr">type</span> <span class="kt">DeRef</span> <span class="kt">Expr</span>        <span class="ow">=</span> <span class="kt">ExprF</span>
</span><span class="line">  <span class="n">mapDeRef</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">AddF</span> <span class="o">&lt;$&gt;</span> <span class="n">f</span> <span class="n">e0</span> <span class="o">&lt;*&gt;</span> <span class="n">f</span> <span class="n">e1</span>
</span><span class="line">  <span class="n">mapDeRef</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">v</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">LitF</span> <span class="n">v</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We need to make <code>Expr</code> an instance of the <code>MuRef</code> class, which loosely provides
a mapping between the <code>Expr</code> and <code>ExprF</code> types.  <code>ExprF</code> itself is a so-called
‘pattern functor’, which is a parameterized type in which recursive points are
indicated by the parameter.  We need the <code>TypeFamilies</code> pragma for
instantiating the <code>MuRef</code> class, and <code>DeriveFunctor</code> eliminates the need to
manually instantiate a <code>Functor</code> instance for <code>ExprF</code>.</p>

<p>Writing <code>MuRef</code> instances is pretty easy.  For more complicated types you can
often use <code>Data.Traversable.traverse</code> in order to provide the required
implementation for <code>mapDeRef</code>
(<a href="https://stackoverflow.com/questions/23825800/how-to-define-a-muref-instance-for-this-nontrivial-expression-type">example</a>).</p>

<p>With this in place we can use <code>reifyGraph</code> from <code>data-reify</code> in order to
observe the implicit sharing.  Let’s try this on a bite-sized <code>tree 2</code> and note
that it is an IO action:</p>

<pre><code>&gt; reifyGraph (tree 2 :: Expr)
let [(1,AddF 2 2),(2,AddF 3 3),(3,LitF 1)] in 1
</code></pre>

<p>Here we get an abstract syntax <em>graph</em> - rather than a tree - and sharing has
been made explicit.</p>

<p>We can write an interpreter for expressions by internally reifying them as
graphs and then working on those.  <code>reifyGraph</code> is an IO action, but since its
effects are pretty tame I don’t feel too bad about wrapping calls to it in
<code>unsafePerformIO</code>.  Interpreting these graphs must be handled a little
differently from interpreting a tree; a naive ‘tree-like’ evaluator 
will eliminate sharing undesirably:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">naiveEval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">naiveEval</span> <span class="n">expr</span> <span class="ow">=</span> <span class="n">gEval</span> <span class="n">reified</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">reified</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="n">reifyGraph</span> <span class="n">expr</span>
</span><span class="line">  <span class="n">gEval</span> <span class="p">(</span><span class="kt">Reify</span><span class="o">.</span><span class="kt">Graph</span> <span class="n">env</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">r</span> <span class="kr">where</span>
</span><span class="line">    <span class="n">go</span> <span class="n">j</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">lookup</span> <span class="n">j</span> <span class="n">env</span> <span class="kr">of</span>
</span><span class="line">      <span class="kt">Just</span> <span class="p">(</span><span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">go</span> <span class="n">a</span> <span class="o">+</span> <span class="n">go</span> <span class="n">b</span>
</span><span class="line">      <span class="kt">Just</span> <span class="p">(</span><span class="kt">LitF</span> <span class="n">d</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="n">d</span>
</span><span class="line">      <span class="kt">Nothing</span>         <span class="ow">-&gt;</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This evaluator fails the <code>tree 50</code> test:</p>

<pre><code>&gt; naiveEval (tree 50)
-- hang
</code></pre>

<p>We need to use a more appropriately graph-y method to traverse and interpret
this (directed, acyclic) graph.  Here’s an idea:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Topological_sorting">topologically sort</a> the
graph, yielding a linear ordering of vertices such that for every edge
$u \to v$, $v$ is ordered before $u$.</li>
  <li>iterate through the sorted vertices, interpreting them as desired and storing
the interpretation</li>
  <li>look up the previously-interpreted vertices as needed</li>
</ul>

<p>We can use the <code>Data.Graph</code> module from the <code>containers</code> library to deal with
the topological sorting and vertex lookups.  The following graph-based
evaluator gets the job done:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">import</span> <span class="nn">Data.Graph</span>
</span><span class="line"><span class="kr">import</span> <span class="nn">Data.Maybe</span>
</span><span class="line">
</span><span class="line"><span class="nf">graphEval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">graphEval</span> <span class="n">expr</span> <span class="ow">=</span> <span class="n">consume</span> <span class="n">reified</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">reified</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="p">(</span><span class="n">toGraph</span> <span class="o">&lt;$&gt;</span> <span class="n">reifyGraph</span> <span class="n">expr</span><span class="p">)</span>
</span><span class="line">  <span class="n">toGraph</span> <span class="p">(</span><span class="kt">Reify</span><span class="o">.</span><span class="kt">Graph</span> <span class="n">env</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">graphFromEdges</span> <span class="o">.</span> <span class="n">map</span> <span class="n">toNode</span> <span class="o">$</span> <span class="n">env</span>
</span><span class="line">  <span class="n">toNode</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
</span><span class="line">  <span class="n">toNode</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="kt">LitF</span> <span class="n">d</span><span class="p">)</span>   <span class="ow">=</span> <span class="p">(</span><span class="kt">LitF</span> <span class="n">d</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nf">consume</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">Graph</span><span class="p">,</span> <span class="kt">Vertex</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">ExprF</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">consume</span> <span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vmap</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">go</span> <span class="p">(</span><span class="n">reverse</span> <span class="o">.</span> <span class="n">topSort</span> <span class="o">$</span> <span class="n">g</span><span class="p">)</span> <span class="kt">[]</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">go</span> <span class="kt">[]</span> <span class="n">acc</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">head</span> <span class="n">acc</span>
</span><span class="line">  <span class="n">go</span> <span class="p">(</span><span class="n">v</span><span class="kt">:</span><span class="n">vs</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">=</span>
</span><span class="line">    <span class="kr">let</span> <span class="n">nacc</span> <span class="ow">=</span> <span class="n">evalNode</span> <span class="p">(</span><span class="n">vmap</span> <span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="kt">:</span> <span class="n">acc</span>
</span><span class="line">    <span class="kr">in</span>  <span class="n">go</span> <span class="n">vs</span> <span class="n">nacc</span>
</span><span class="line">
</span><span class="line"><span class="nf">evalNode</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="kt">ExprF</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
</span><span class="line"><span class="nf">evalNode</span> <span class="p">(</span><span class="kt">LitF</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span>   <span class="kr">_</span> <span class="ow">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span><span class="line"><span class="nf">evalNode</span> <span class="p">(</span><span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="n">l</span> <span class="ow">=</span>
</span><span class="line">  <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">fromJust</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">lookup</span> <span class="n">a</span> <span class="n">l</span> <span class="o">&lt;*&gt;</span> <span class="n">lookup</span> <span class="n">b</span> <span class="n">l</span><span class="p">)</span>
</span><span class="line">  <span class="kr">in</span>  <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In a serious implementation I’d want to use a more appropriate caching
structure and avoid the partial functions like <code>fromJust</code> and <code>head</code>, but you
get the point.  In any case, this evaluator passes the <code>tree 50</code> test without
issue:</p>

<pre><code>&gt; graphEval (tree 50)
1125899906842624
</code></pre>

<h2 id="making-sharing-explicit">Making Sharing Explicit</h2>

<p>Instead of working around the lack of sharing in our language, we can augment
it by adding the necessary sharing constructs.  In particular, we can add our
own let-binding that piggybacks on Haskell’s <code>let</code>.  Here’s an enhanced
language (using the same <code>Num</code> instance as before):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Expr</span> <span class="ow">=</span>
</span><span class="line">    <span class="kt">Lit</span> <span class="kt">Int</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Add</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Let</span> <span class="kt">Expr</span> <span class="p">(</span><span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The new <code>Let</code> constructor implements <em>higher-order abstract syntax</em>, or HOAS.
There are some immediate consequences of this: we can’t derive instances of our
language for typeclasses like <code>Eq</code>, <code>Ord</code>, and <code>Show</code>, and interpreting
everything becomes a bit more painful.  But, we don’t need to make any use of
<code>data-reify</code> in order to share expressions, since the language now handles that
&#8216;a la carte.  Here’s an efficient evaluator:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">d</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">d</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">e1</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Let</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span>
</span><span class="line">  <span class="kr">let</span> <span class="n">shared</span> <span class="ow">=</span> <span class="kt">Lit</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e0</span><span class="p">)</span>
</span><span class="line">  <span class="kr">in</span>  <span class="n">eval</span> <span class="p">(</span><span class="n">e1</span> <span class="n">shared</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In particular, note that we need a sort of back-interpreter to re-embed shared
expressions into our language while interpreting them.  Here we use <code>Lit</code> to
do that, but this is more painful if we want to implement, say, a pretty
printer; in that case we need a parser such that <code>print (parse x) == x</code> (see 
<a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf">here</a>).</p>

<p>We also can’t use the existing <code>tree</code> function.  Here’s the HOAS equivalent,
which is no longer polymorphic in its return type:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">tree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
</span><span class="line"><span class="nf">tree</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">tree</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Let</span> <span class="p">(</span><span class="n">tree</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">\</span><span class="n">shared</span> <span class="ow">-&gt;</span> <span class="n">shared</span> <span class="o">+</span> <span class="n">shared</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Using that, we can see that sharing is preserved just fine:</p>

<pre><code>&gt; eval (tree 50)
1125899906842624
</code></pre>

<p>Another way to make sharing explicit is to use a paramterized HOAS, known as
PHOAS.  This requires the greatest augmentation of the original language
(recycling the same <code>Num</code> instance):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="kr">data</span> <span class="kt">Expr</span> <span class="n">a</span> <span class="ow">=</span>
</span><span class="line">    <span class="kt">Lit</span> <span class="kt">Int</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Expr</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Expr</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Let</span> <span class="p">(</span><span class="kt">Expr</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="n">a</span><span class="p">)</span>
</span><span class="line">  <span class="o">|</span> <span class="kt">Var</span> <span class="n">a</span>
</span><span class="line">
</span><span class="line"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">d</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">d</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">v</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">v</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">e0</span> <span class="o">+</span> <span class="n">eval</span> <span class="n">e1</span>
</span><span class="line"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Let</span> <span class="n">e</span> <span class="n">f</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">eval</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we parameterize the expression type and add both <code>Let</code> and <code>Var</code>
constructors to the language.  Sharing expressions explicitly now takes a
slightly different form than in the HOAS version:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">tree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="n">b</span>
</span><span class="line"><span class="nf">tree</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">tree</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Let</span> <span class="p">(</span><span class="n">tree</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">((</span><span class="nf">\</span><span class="n">shared</span> <span class="ow">-&gt;</span> <span class="n">shared</span> <span class="o">+</span> <span class="n">shared</span><span class="p">)</span> <span class="o">.</span> <span class="kt">Var</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The <code>Var</code> term wraps the intermediate computation, which is then passed to the
semantics-defining lambda.  Sharing is again preserved in the language:</p>

<pre><code>&gt; eval $ tree 50
1125899906842624
</code></pre>

<p>Here, however, we don’t need the same kind of back-interpreter that we did when
using HOAS.  It’s easy to write a pretty-printer that observes sharing, for
example (from <a href="http://ropas.snu.ac.kr/~bruno/papers/ASGDSL.pdf">here</a>):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="haskell"><span class="line"><span class="nf">text</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">e</span> <span class="mi">0</span> <span class="kr">where</span>
</span><span class="line">  <span class="n">go</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">j</span><span class="p">)</span>     <span class="kr">_</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">j</span>
</span><span class="line">  <span class="n">go</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="n">c</span> <span class="ow">=</span> <span class="s">&quot;(Add &quot;</span> <span class="o">++</span> <span class="n">go</span> <span class="n">e0</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">go</span> <span class="n">e1</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</span><span class="line">  <span class="n">go</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">x</span><span class="p">)</span> <span class="kr">_</span>     <span class="ow">=</span> <span class="n">x</span>
</span><span class="line">  <span class="n">go</span> <span class="p">(</span><span class="kt">Let</span> <span class="n">e0</span> <span class="n">e1</span><span class="p">)</span> <span class="n">c</span> <span class="ow">=</span> <span class="s">&quot;(Let &quot;</span> <span class="o">++</span> <span class="n">v</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">go</span> <span class="n">e0</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">++</span>
</span><span class="line">                     <span class="s">&quot; in &quot;</span> <span class="o">++</span> <span class="n">go</span> <span class="p">(</span><span class="n">e1</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</span><span class="line">    <span class="kr">where</span> <span class="n">v</span> <span class="ow">=</span> <span class="s">&quot;v&quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Which yields the following string representation of our syntax:</p>

<pre><code>&gt; putStrLn . text $ tree 2
(Let v0 (Let v1 1 in (Add v1 v1)) in (Add v0 v0))
</code></pre>

<h2 id="cluing-up">Cluing up</h2>

<p>I’ve gone over several methods of handling sharing in embedded languages:
an external memoizer, observable (implicit) sharing, and adding explicit
sharing via adding a HOAS or PHOAS let-binding to the original language.  Some
may be more convenient than others, depending on what you’re trying to do.</p>

<p>I’ve dumped code for the
<a href="https://gist.github.com/jtobin/89d741df8aaaa33eb567">minimal</a>,
<a href="https://gist.github.com/jtobin/3fc26d852af9e82e378e">HOAS</a>, and
<a href="https://gist.github.com/jtobin/e3e945f3c761cbc6ad43">PHOAS</a> examples in the
some gists.</p>

</div>


  <footer>
    <p class="meta">
      
  


      
      


    </p>
    
      <div class="sharing">
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left articlenav" href="/blog/2014/03/17/sampling-functions-vs-generative-models/" title="Previous Post: Sampling Functions and Generative Models">&laquo; Sampling Functions and Generative Models</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  &copy; 2014 Jared Tobin
  <span class="credit" style="float: right">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$', '$'] ],
      displayMath: [ ['$$', '$$']],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
  });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</body>
</html>
